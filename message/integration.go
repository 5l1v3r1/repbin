package message

import (
	"errors"

	log "github.com/repbin/repbin/deferconsole"
	"github.com/repbin/repbin/hashcash"
)

/*
Send Input:
	message
	messageType
	signer(pubkey,privkey,nonce) -> optional
	senderpriv   -> optional
	receivepubs  -> optional
Send Output:
	message
	messageID
	temp-privkey -> optional
	padkey -> optional
	error

Receive Input:
	message
	receive-privkeys -> optional (do key match), callback?
	expect-senderpub -> optional
Receive Output:
	message
	messageID
	messageType
	error
*/

// VersionID of this release
const VersionID = "0.0.1 very alpha"

var (
	//ErrNoKeys is returned if no method for private key discovery is available
	ErrNoKeys = errors.New("message: No private keys available")
	// ErrBadMessageID is returned when the message ID signed is different from the one calculated
	ErrBadMessageID = errors.New("message: Unexpected message ID")
	// ErrBadSender is returned when another sender was expected
	ErrBadSender = errors.New("message: Unexpected sender")
)

const (
	// DefaultTotalLength is the size of the message.
	DefaultTotalLength = BodyMaxLength + SignHeaderSize + KeyHeaderSize
	// DefaultPadToLength is the size of the body including random padding
	DefaultPadToLength = 4096
	// DefaultHashCashBits is the minimum number of hashcash bits requried
	DefaultHashCashBits = byte(23)
)

// CalcMaxEmbedded returns the maximum size of data that can be included in a message of TotalLength size
func CalcMaxEmbedded(TotalLength int) int {
	return TotalLength - SignHeaderSize - KeyHeaderSize
}

// Encrypt encrypts a message
func (sender Sender) Encrypt(messageType byte, message []byte) (encMessage []byte, meta *MetaDataSend, err error) {
	return sender.encrypt(messageType, message, false)
}

// EncryptRepost encrypts a message for reposting, meaning that the deterministic padding is thrown away and there is no encoding
func (sender Sender) EncryptRepost(messageType byte, message []byte) (rewrapMessage []byte, meta *MetaDataSend, err error) {
	return sender.encrypt(messageType, message, true)
}

// Sender defines sender behavior
type Sender struct {
	Signer                    *SignKeyPair   // Optional, autogenerated when missing
	SenderPrivateKey          *Curve25519Key // Optional. Use ephemeral key if missing
	ReceiveConstantPublicKey  *Curve25519Key // Optional. Constant public key of receiver, ephemeral keys will be used if missing
	ReceiveTemporaryPublicKey *Curve25519Key // MUST be set IF ReceiveConstantPublicKey is set
	// TotalLength is the total size of body including padding.
	// Set to default if missing if 0
	TotalLength int
	// PadToLength will pad the body to PadToLength size of random padding before adding deterministic padding, if any.
	// Set to default if missing if 0
	PadToLength int
	// HashCashBits is the minimum number of hashcash bits required. Will be set to default if missing
	HashCashBits byte
}

// MetaDataSend contains metadata for the message
type MetaDataSend struct {
	MessageID              [MessageIDSize]byte // MessageID of the message (calculated from header+body)
	PadKey                 *[PadKeySize]byte   // Will be set if deterministic padding is appended and meaningful
	MessageKey             *Curve25519Key      // Will be set if ephemeral recipient keys are used
	ReceiverConstantPubKey *Curve25519Key
}

// encrypt message
func (sender *Sender) encrypt(messageType byte, message []byte, repost bool) (encMessage []byte, meta *MetaDataSend, err error) {
	var Signer *SignKeyPair
	meta = new(MetaDataSend)
	// Set defaults
	if sender.HashCashBits <= 0 {
		sender.HashCashBits = DefaultHashCashBits
	}
	if sender.TotalLength <= 0 {
		sender.TotalLength = DefaultTotalLength
	}
	if sender.PadToLength <= 0 {
		sender.PadToLength = DefaultPadToLength
	}
	// Get signer
	Signer = sender.Signer
	// Verify if (optional) signer produces enough bits, if not, generate a new one
	if Signer != nil {
		ok, _ := hashcash.TestNonce(Signer.PublicKey[:], Signer.Nonce[:], sender.HashCashBits)
		if !ok {
			log.Debugf("Given signer does not produce enough HashCash bits: %x", Signer.PublicKey)
			Signer = nil
		}
	}
	if Signer == nil {
		// We have no signer, so we generate one. Don't make public for sender instance
		log.Info("Generating new HashCash signer...")
		Signer, err = GenKey(sender.HashCashBits)
		if err != nil {
			return nil, nil, err
		}
		log.Info("...new HashCash signer generated")
	}
	// Generate sender keypack. if SenderPrivateKey is set, it will be used
	keypackSender, err := GenSenderKeys(sender.SenderPrivateKey)
	if err != nil {
		return nil, nil, err
	}
	// Generate peer's keypack. If keys are known, they are used
	keypackPeer, err := GenReceiveKeys(sender.ReceiveConstantPublicKey, sender.ReceiveTemporaryPublicKey)
	if err != nil {
		return nil, nil, err
	}
	// We generated new keys, they have to be made available
	if sender.ReceiveConstantPublicKey == nil {
		log.Debug("Using one-time receiver key")
		meta.MessageKey = keypackPeer.ConstantPrivKey // TemporaryPrivKey is deterministic
	}
	// Generate the nonce
	nonce, err := GenNonce()
	if err != nil {
		return nil, nil, err
	}
	myMessage := new(Message)
	// Create our KeyHeader
	myMessage.Header = PackKeyHeader(keypackSender, keypackPeer, nonce)
	// Calculate our shared secret. We are the sender, so last param is true
	sharedSecret := CalcSharedSecret(keypackSender, keypackPeer, nonce, true)
	// Set encryption/padding parameters
	bodyEncryption := EncryptBodyDef{
		IV:           *GenIV(myMessage.Header[:]), // Generate IV from key header, which is uniqueish
		SharedSecret: sharedSecret,
		MessageType:  messageType,
		TotalLength:  sender.TotalLength - SignHeaderSize - KeyHeaderSize,
		PadToLength:  sender.PadToLength,
	}
	log.Debug("Encrypting...")
	body, err := bodyEncryption.EncryptBody(message)
	if err != nil {
		return nil, nil, err
	}
	log.Debug("...encryption done")
	// Convert body to bytes
	myMessage.Body = body.Bytes()
	// Generate the message ID. This has to happen the same way for repost and standard message
	meta.MessageID = *myMessage.CalcMessageID()
	meta.ReceiverConstantPubKey = keypackPeer.ConstantPubKey
	myMessage.SignatureHeader = Signer.Sign(meta.MessageID)

	if repost {
		log.Debug("This is a repost-message!")
		//Cut out padding and set padkey
		meta.PadKey = &body.PadKey
		myMessage.Body = body.BytesNoPadding()
		//Repost messages are not base64 encoded since they are embedded anyways
		return myMessage.Bytes(), meta, nil
	}
	return EncodeBase64(myMessage.Bytes()), meta, nil
}

// Receiver defines receiver functionality
type Receiver struct {
	SenderPublicKey            *Curve25519Key // Optional. If set, verify for message
	ReceiveConstantPrivateKey  *Curve25519Key // Optional. Will use callback if not set
	ReceiveTemporaryPrivateKey *Curve25519Key // Optional. Will try to generate from ReceiveConstantPrivateKey, then Callback
	// KeyCallBack is an optional function to get private keys. It takes a public key as parameter and expects the private key or nil as return
	KeyCallBack func(*Curve25519Key) *Curve25519Key
	// HashCashBits is the minimum number of hashcash bits required. Will be set to default if missing
	HashCashBits byte
}

// MetaDataRecieve contains data from decryption
type MetaDataRecieve struct {
	SenderConstantPublicKey   *Curve25519Key      // Public key used by sender
	ReceiveConstantPublicKey  *Curve25519Key      // Constant public key of recipient
	ReceiveTemporaryPublicKey *Curve25519Key      // Temporary public key of recipient
	MessageID                 [MessageIDSize]byte // MessageID as calculated
	MessageType               byte                // MessageType of message
}

// Decrypt applies decryption & verification to a messsage
func (receiver Receiver) Decrypt(encMessage []byte) (message []byte, meta *MetaDataRecieve, err error) {
	// Set defaults
	if receiver.HashCashBits <= 0 {
		receiver.HashCashBits = DefaultHashCashBits
	}
	encmsg, err := Base64Message(encMessage).Decode()
	if err != nil {
		return nil, nil, err
	}
	messageS, err := ParseMessage(encmsg)
	if err != nil {
		return nil, nil, err
	}
	// Check signature
	details, err := VerifySignature(*messageS.SignatureHeader, receiver.HashCashBits)
	if err != nil {
		return nil, nil, err
	}
	meta = new(MetaDataRecieve)
	msgIDver := messageS.CalcMessageID()
	meta.MessageID = *msgIDver
	if *msgIDver != details.MsgID {
		return nil, meta, ErrBadMessageID
	}
	senderKeys, receiverKeys, nonce := ParseKeyHeader(messageS.Header)
	meta.SenderConstantPublicKey = senderKeys.ConstantPubKey
	meta.ReceiveConstantPublicKey = receiverKeys.ConstantPubKey
	meta.ReceiveTemporaryPublicKey = receiverKeys.TemporaryPubKey

	if receiver.SenderPublicKey != nil && *senderKeys.ConstantPubKey != *receiver.SenderPublicKey {
		return nil, meta, ErrBadSender
	}
	if receiver.ReceiveConstantPrivateKey == nil && receiver.KeyCallBack == nil {
		return nil, meta, ErrNoKeys
	}
	// Fill in Private Keys
	haveKeys := false
	if receiver.KeyCallBack != nil && receiver.ReceiveConstantPrivateKey == nil {
		receiver.ReceiveConstantPrivateKey = receiver.KeyCallBack(receiverKeys.ConstantPubKey)
		receiver.ReceiveTemporaryPrivateKey = receiver.KeyCallBack(receiverKeys.TemporaryPubKey)
	}
	if receiver.ReceiveConstantPrivateKey != nil {
		haveKeys = receiverKeys.MatchPrivate(receiver.ReceiveConstantPrivateKey, receiver.ReceiveTemporaryPrivateKey)
	}
	if !haveKeys {
		return nil, meta, ErrNoKeys
	}
	// We are receiving. Swap keypacks and set sending==false
	sharedSecret := CalcSharedSecret(receiverKeys, senderKeys, nonce, false)
	bodyDecryption := DecryptBodyDef{
		IV:           *GenIV(messageS.Header[:]), // Generate IV from key header, which is uniqueish
		SharedSecret: sharedSecret,
	}
	bodyDecryption.DecryptBody(messageS.Body)
	data, msgtype, err := bodyDecryption.DecryptBody(messageS.Body)
	if err != nil {
		return nil, meta, err
	}
	meta.MessageType = msgtype
	return data, meta, nil
}
